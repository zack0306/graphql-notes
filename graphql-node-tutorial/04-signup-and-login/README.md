# Signup & Login
In this section, we implement authentication functionality


## Securing Data Access
There are two areas where authentication and data protection are important in this application:
1. Securing access to the Prisma database service
2. Giving login functionality to the application's users


## Securing Access to the Prisma Database Service
If you want to access the Prisma database service over HTTP, you need to add an authentication token to the `Authorization` field of the HTTP header
- This authentication token is a **JSON Web Token**
  - Needs to be signed with the Prisma **Service Secret**
  - This secret is in `prisma.yml`
- The token is usually automatically generated by Prisma


## Offering Login Functionality to Application Users
The `secret` and JWT only protects your database from unauthorized access
- Doesn't authenticate application users
- Developers can implement any type of authentication flow for their GraphQL server

For this application, we will use another JWT
- This means we need to come up with an **Application Secret**
- It will be used for issuing authentication tokens to the users


## Signup
Signup consists of these steps:
1. Server receives a `signup` mutation with `email`, `password`, and `name` of a new user
2. Server creates a new user and stores `name`, `email`, and a hashed version of `password`
3. Server generates a JWT by signing the token's payload (the user's `id`) using the application secret
4. Server returns authentication token and user info to the client


## Login
Logging in consists of these steps:
1. Server receives a `login` mutation with `email` and `password`
2. Server compares the hashed `password` in the database to the user-sent password
3. If the passwords match, the server generates a JWT by signing the token's payload (user's `id`) with the application secret
4. Server returns authentication token and user info to the client that made the request


## Implementing the `signup` Mutation
First, define the application secret in `utils.js`

Next, we will use libraries for generating and validating JWTs as well as hashing user passwords
- `jsonwebtoken`
- `bcryptjs`

Now, we can update the application schema to start adding the new functionality
- Add the `signup` mutation to `src/schema.graphql`:

```
type Mutation {
  post(url: String!, description: String!): Link!
  signup(email: String!, password: String!, name: String!): AuthPayload
}
```

- Here we see an `AuthPayload` type that hasn't been defined yet, so we add it to `src/schema.graphql`:

```
type AuthPayload {
  token: String
  user: User
}
```

- Again, we see an undefined type `User`
- Since `User` information must be persisted, we'll add it to `database/datamodel.graphql` first:

```
type User {
  id: ID! @unique
  name: String!
  email: String! @unique
  password: String!
}
```

- Since we added a `User` type to `database/datamodel.graphql`, we need to deploy Prisma

Now that the `User` type is part of the Prisma schema, we must add it to the application schema
- When doing so, we don't want to expose the `password` field
- This means we will have to redefine it instead of just importing Prisma's autogenerated types
- In `src/schema.graphql`:

```
type User {
  id: ID!
  name: String!
  email: String!
}
```

- Since this type definition doesn't have a `password` field, clients cannot query it

Now we implement the `signup` resolver in `Mutation.js`:

```javascript
const signup = async (parent, args, context, info) => {
  const password = await bcrypt.hash(args.password, 10);
  const user = await context.db.mutation.createUser({
    data: { ...args, password },
  });

  const token = jwt.sign({ userId: user.id }, APP_SECRET);

  return { token, user };
};
```


## Implementing the `login` Mutation
We need to add the `login` mutation to the application schema:

```
type Mutation {
  post(url: String!, description: String!): Link!
  signup(email: String!, password: String!, name: String!): AuthPayload
  login(email: String!, password: String!): AuthPayload
}
```

Next, implement the resolver in `src/resolvers/Mutation.js`:

```javascript
const login = async (parent, args, context, info) => {
  const user = await context.db.query.user({ where: { email: args.email } });
  if (!user) throw new Error(`Could not find user with email: ${args.email}`);

  const valid = await bcrypt.compare(args.password, user.password);
  if (!valid) throw new Error('Invalid password');

  const token = jwt.sign({ userId: user.id }, APP_SECRET);
  return { token, user };
};
```

After exporting the new resolver, you can test this mutation in the playground:

```
mutation {
  login(email: "gorogorogoro@gmail.com", password: "kiryuchan") {
    token
  }
}
```
